<!DOCTYPE html>
<html lang="kk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Particle Universe | Ainur</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .title {
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.4rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-shadow: 0 0 15px rgba(0, 200, 255, 0.8);
            font-weight: 400;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1rem;
            letter-spacing: 2px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 25px;
            border-radius: 30px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            animation: pulse 2s infinite alternate;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.05); transform: scale(1); }
            100% { box-shadow: 0 0 20px rgba(255, 0, 150, 0.4); transform: scale(1.02); }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 20;
            font-size: 1.8rem;
            letter-spacing: 4px;
            text-shadow: 0 0 20px #00ffff;
            transition: opacity 1s ease-out;
        }
    </style>

    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">ҒАРЫШ ЖҮКТЕЛУДЕ...</div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="title">Ainur Universe</div>
        <div class="instructions">Экранды басыңыз (Келесі образға өту)</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Тұман аздап азайтылды, фигуралар анық көрінуі үшін

        // Камера жақындатылды (12-ден 9-ға) образдар үлкен болуы үшін
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = window.innerWidth < 768 ? 14 : 9; // Мобильді экранда кішірек (алысырақ) көрінуі үшін
        camera.position.y = 1;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- POST-PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.5,  // Күшейтілген жарқырау (Strength)
            0.6,  // Radius
            0.1   // Threshold
        );
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- PARTICLE CONFIGURATION ---
        const PARTICLE_COUNT = 50000; // Бөлшектер саны сәл көбейтілді
        let currentShapeIndex = 0;
        
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // --- SHAPE GENERATORS ---
        // 1. Сфера (Sphere)
        function generateSphere() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = 4.2; // Кішірейтілді (5.5-тен 4.2-ге дейін)
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = r + (Math.random() * 0.8 - 0.4);

                arr[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                arr[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                arr[i * 3 + 2] = radius * Math.cos(phi);
            }
            return arr;
        }

        // 2. Сатурн жүйесі (Saturn)
        function generateSaturnSystem() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                if (i < 15000) {
                    const r = 2.0 * Math.cbrt(Math.random());
                    const theta = 2 * Math.PI * Math.random();
                    const phi = Math.acos(2 * Math.random() - 1);
                    arr[i3] = r * Math.sin(phi) * Math.cos(theta) - 4;
                    arr[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    arr[i3 + 2] = r * Math.cos(phi) - 2;
                } else if (i < 35000) {
                    const saturnIdx = i - 15000;
                    if (saturnIdx < 5000) {
                        const r = 1.6 * Math.cbrt(Math.random());
                        const theta = 2 * Math.PI * Math.random();
                        const phi = Math.acos(2 * Math.random() - 1);
                        arr[i3] = r * Math.sin(phi) * Math.cos(theta) + 3;
                        arr[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                        arr[i3 + 2] = r * Math.cos(phi) + 1;
                    } else {
                        const r = 2.5 + Math.random() * 2.0; 
                        const theta = 2 * Math.PI * Math.random();
                        const tiltX = Math.PI / 6;
                        const tiltZ = -Math.PI / 12; 

                        let x = r * Math.cos(theta);
                        let y = (Math.random() - 0.5) * 0.15;
                        let z = r * Math.sin(theta);

                        let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
                        let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
                        let x2 = x * Math.cos(tiltZ) - y1 * Math.sin(tiltZ);
                        let y2 = x * Math.sin(tiltZ) + y1 * Math.cos(tiltZ);

                        arr[i3] = x2 + 3;
                        arr[i3 + 1] = y2;
                        arr[i3 + 2] = z1 + 1;
                    }
                } else {
                    const r = 1.0 * Math.cbrt(Math.random());
                    const theta = 2 * Math.PI * Math.random();
                    const phi = Math.acos(2 * Math.random() - 1);
                    arr[i3] = r * Math.sin(phi) * Math.cos(theta) + 1;
                    arr[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) + 4;
                    arr[i3 + 2] = r * Math.cos(phi) - 3;
                }
            }
            return arr;
        }

        // 3. Ainur Жазуы (Text)
        function generateText(text) {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            const canvas = document.createElement('canvas');
            canvas.width = 1200;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 300px "Segoe UI", Arial, sans-serif'; // Қаріп үлкейтілді
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const validPixels = [];
            
            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    const alphaIndex = (y * canvas.width + x) * 4 + 3;
                    if (imgData[alphaIndex] > 128) {
                        validPixels.push({ x: x - canvas.width / 2, y: canvas.height / 2 - y });
                    }
                }
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pixel = validPixels[i % validPixels.length];
                const spread = 0.4;
                // x осі теріс болмауы үшін дұрыс бағытталды. Масштаб кішірейтілді (0.035 -> 0.025)
                arr[i * 3] = (pixel.x * 0.025) + (Math.random() - 0.5) * spread;
                arr[i * 3 + 1] = (pixel.y * 0.025) + (Math.random() - 0.5) * spread;
                arr[i * 3 + 2] = (Math.random() - 0.5) * 2.0; 
            }
            return arr;
        }

        // 4. Жүрек (Heart) - ЖАҢА ОБРАЗ
        function generateHeart() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI * 2;
                
                // Жүрек формуласы
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4; 
                
                // Масштаб
                x *= 0.35;
                y *= 0.35;
                
                // Көлем беру үшін кішкене шашырату
                x += (Math.random() - 0.5) * 1.5;
                y += (Math.random() - 0.5) * 1.5;
                
                arr[i * 3] = x;
                arr[i * 3 + 1] = y + 1; // Жоғарырақ көтеру
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 5. Киберпанк Текше (CyberCube) - ЖАҢА ОБРАЗ
        function generateCyberCube() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            const size = 7.0;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                if (Math.random() > 0.4) {
                    // Кубтың қабырғалары (Edges)
                    let edge = Math.floor(Math.random() * 12);
                    let t = (Math.random() - 0.5) * size;
                    let s1 = (Math.random() > 0.5 ? 1 : -1) * (size/2);
                    let s2 = (Math.random() > 0.5 ? 1 : -1) * (size/2);
                    
                    if (edge < 4) { x = t; y = s1; z = s2; }
                    else if (edge < 8) { x = s1; y = t; z = s2; }
                    else { x = s1; y = s2; z = t; }
                    
                    // Глитч эффект (кішігірім ауытқулар)
                    if (Math.random() > 0.8) { 
                        x += (Math.random()-0.5)*1.5; 
                        y += (Math.random()-0.5)*1.5; 
                        z += (Math.random()-0.5)*1.5; 
                    }
                } else {
                    // Ішіндегі деректер торабы (Data Matrix Grid)
                    const step = size / 4;
                    x = Math.floor((Math.random() - 0.5) * 5) * step;
                    y = Math.floor((Math.random() - 0.5) * 5) * step;
                    z = Math.floor((Math.random() - 0.5) * 5) * step;
                    
                    x += (Math.random() - 0.5) * 0.4;
                    y += (Math.random() - 0.5) * 0.4;
                    z += (Math.random() - 0.5) * 0.4;
                }
                
                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 6. ДНҚ Спиралі (DNA Helix) - ЖАҢА ОБРАЗ
        function generateDNA() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const height = 16;
                let y = (Math.random() - 0.5) * height; // const орнына let қолданылды
                const phase = y * 1.5; 
                const radius = 2.5;
                
                let x, z;
                
                if (Math.random() > 0.25) {
                    // Екі негізгі спираль (Backbones)
                    const strand = Math.random() > 0.5 ? 0 : Math.PI;
                    x = Math.cos(phase + strand) * radius;
                    z = Math.sin(phase + strand) * radius;
                    
                    x += (Math.random() - 0.5) * 0.8;
                    y += (Math.random() - 0.5) * 0.8;
                    z += (Math.random() - 0.5) * 0.8;
                } else {
                    // Байланыстар (Connections)
                    const step = Math.round(y * 3) / 3; 
                    const p = step * 1.5;
                    const r = (Math.random() - 0.5) * radius * 1.8; 
                    x = Math.cos(p) * r;
                    z = Math.sin(p) * r;
                    y = step + (Math.random() - 0.5) * 0.3; 
                }
                
                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 7. Торус Толқыны (Torus Wave)
        function generateTorusWave() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R = 4.5; // Үлкейтілді
                const r = 1.5 + Math.random() * 0.6; 
                
                let x = (R + r * Math.cos(v)) * Math.cos(u);
                let y = (R + r * Math.cos(v)) * Math.sin(u);
                let z = r * Math.sin(v);
                
                z += Math.sin(u * 5) * 0.6;

                arr[i * 3] = x;
                arr[i * 3 + 1] = z; 
                arr[i * 3 + 2] = y;
            }
            return arr;
        }

        // 8. Галактика бұлты (Galaxy)
        function generateGalaxyCloud() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const radius = Math.random() * 14; // Үлкейтілді
                const angle = Math.random() * Math.PI * 2;
                const spiralRadius = radius + (Math.random() * 2 - 1);
                
                arr[i * 3] = Math.cos(angle + radius * 0.5) * spiralRadius;
                arr[i * 3 + 1] = (Math.random() - 0.5) * (15 - radius); 
                arr[i * 3 + 2] = Math.sin(angle + radius * 0.5) * spiralRadius;
            }
            return arr;
        }

        // Формалар массивтері
        const shapes = [
            generateSphere(),
            generateSaturnSystem(),
            generateText("Ainur"),
            generateHeart(),       // Жаңа
            generateCyberCube(),   // Жаңа (Киберпанк)
            generateDNA(),         // Жаңа
            generateTorusWave(),
            generateGalaxyCloud()
        ];

        // Түрлі формалар үшін динамикалық түстер палитрасы
        const colorPalettes = [
            [new THREE.Color(0.6, 0.1, 1.0), new THREE.Color(0.1, 1.0, 0.6), new THREE.Color(0.1, 0.6, 1.0)], // Сфера: Күлгін/Көк
            [new THREE.Color(1.0, 0.5, 0.1), new THREE.Color(1.0, 0.8, 0.2), new THREE.Color(0.2, 0.8, 1.0)], // Сатурн: Қызғылт сары/Алтын
            [new THREE.Color(1.0, 0.2, 0.6), new THREE.Color(1.0, 1.0, 1.0), new THREE.Color(0.2, 1.0, 1.0)], // Ainur: Ақ/Қызғылт
            [new THREE.Color(1.0, 0.0, 0.2), new THREE.Color(1.0, 0.4, 0.6), new THREE.Color(0.8, 0.0, 0.3)], // Жүрек: Қызыл
            [new THREE.Color(1.0, 0.0, 1.0), new THREE.Color(0.0, 1.0, 1.0), new THREE.Color(1.0, 1.0, 0.0)], // Киберпанк: Неон
            [new THREE.Color(0.0, 1.0, 0.5), new THREE.Color(0.0, 0.8, 1.0), new THREE.Color(1.0, 1.0, 1.0)], // ДНҚ: Жасыл/Көгілдір
            [new THREE.Color(0.1, 1.0, 0.3), new THREE.Color(0.1, 0.5, 1.0), new THREE.Color(1.0, 0.1, 0.5)], // Торус: Радуга
            [new THREE.Color(0.05, 0.1, 0.8), new THREE.Color(0.5, 0.0, 1.0), new THREE.Color(1.0, 1.0, 1.0)]  // Галактика: Терең көк
        ];

        // Бастапқы жағдай
        for (let i = 0; i < positions.length; i++) {
            positions[i] = shapes[0][i];
            targetPositions[i] = shapes[0][i];
        }

        // --- SHADER MATERIAL ---
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const randoms = new Float32Array(PARTICLE_COUNT);
        for (let i = 0; i < PARTICLE_COUNT; i++) randoms[i] = Math.random();
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector3(0, 0, 0) },
                uColor1: { value: colorPalettes[0][0].clone() },
                uColor2: { value: colorPalettes[0][1].clone() },
                uColor3: { value: colorPalettes[0][2].clone() },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                uniform float uTime;
                uniform vec3 uMouse;
                
                attribute float aRandom;
                
                varying vec3 vPos;
                varying float vOpacity;

                void main() {
                    vPos = position;
                    vec3 pos = position;

                    // Тышқаннан қашу эффектісі
                    float dist = distance(pos, uMouse);
                    float maxDist = 3.5;
                    if (dist < maxDist) {
                        vec3 dir = normalize(pos - uMouse);
                        float force = pow((maxDist - dist) / maxDist, 2.0); 
                        pos += dir * force * 1.8; 
                    }

                    // Кішкене тербеліс
                    pos.x += sin(uTime * 1.2 + aRandom * 10.0) * 0.06;
                    pos.y += cos(uTime * 0.8 + pos.x) * 0.06;
                    pos.z += sin(uTime * 1.5 + pos.y) * 0.06;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // Бөлшектер көлемі үлкейтілді
                    gl_PointSize = (30.0 * aRandom + 12.0) * (1.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;

                    vOpacity = 0.5 + 0.5 * sin(uTime * 3.0 + aRandom * 20.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                
                varying vec3 vPos;
                varying float vOpacity;

                void main() {
                    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                    float r = dot(cxy, cxy);
                    if (r > 1.0) discard;
                    
                    float alpha = (1.0 - r) * vOpacity;

                    // Динамикалық түс араластыру
                    float mix1 = sin(vPos.x * 0.4 + uTime * 0.5) * 0.5 + 0.5;
                    float mix2 = cos(vPos.y * 0.4 - uTime * 0.3) * 0.5 + 0.5;

                    vec3 finalColor = mix(mix(uColor1, uColor2, mix1), uColor3, mix2);
                    
                    // Жарқырауды күшейту
                    finalColor *= 1.8;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        setTimeout(() => {
            document.getElementById('loading').style.opacity = '0';
        }, 1200);

        // --- INTERACTION & MORPHING ---
        window.addEventListener('click', () => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            const newShape = shapes[currentShapeIndex];
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = newShape[i];
            }
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(999, 999);
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const targetMousePos = new THREE.Vector3(999, 999, 0);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, targetMousePos);
        });

        window.addEventListener('touchmove', (event) => {
            if(event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(plane, targetMousePos);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.position.z = window.innerWidth < 768 ? 14 : 9; // Адаптация: экран өлшемі өзгергенде камера реттеледі
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            material.uniforms.uTime.value = elapsedTime;

            // Түстерді ақырындап ауыстыру (Lerp colors)
            material.uniforms.uColor1.value.lerp(colorPalettes[currentShapeIndex][0], 0.04);
            material.uniforms.uColor2.value.lerp(colorPalettes[currentShapeIndex][1], 0.04);
            material.uniforms.uColor3.value.lerp(colorPalettes[currentShapeIndex][2], 0.04);

            material.uniforms.uMouse.value.lerp(targetMousePos, 0.1);

            const posAttr = geometry.attributes.position;
            const posArray = posAttr.array;
            let needsUpdate = false;

            for (let i = 0; i < posArray.length; i++) {
                const current = posArray[i];
                const target = targetPositions[i];
                const diff = target - current;
                
                if (Math.abs(diff) > 0.001) {
                    posArray[i] += diff * 0.035; // Morph speed
                    needsUpdate = true;
                }
            }

            if (needsUpdate) posAttr.needsUpdate = true;

            // "Ainur" жазуы (индекс 2) болғанда айналуды тоқтату логикасы
            if (currentShapeIndex === 2) { 
                // Жазу дұрыс оқылуы үшін ең жақын 2*PI бұрышына бұру
                let currentY = particles.rotation.y;
                let nearest2Pi = Math.round(currentY / (Math.PI * 2)) * (Math.PI * 2);
                
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, nearest2Pi, 0.05);
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
            } else {
                // Басқа образдар үзіліссіз айнала береді
                particles.rotation.y += 0.004;
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, Math.sin(elapsedTime * 0.2) * 0.15, 0.05);
            }

            composer.render();
        }

        animate();
    </script>
</body>
</html>